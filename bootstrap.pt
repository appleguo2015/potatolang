fun make_token(t, lex) {
  let tok = list();
  tok = push(tok, t);
  tok = push(tok, lex);
  return tok;
}

fun tok_type(tok) { return get(tok, 0); }
fun tok_lex(tok) { return get(tok, 1); }

fun escape_string(s) {
  let out = "";
  let j = 0;
  while (j < len(s)) {
    let c = char_at(s, j);
    if (c == "\n") {
      out = out + "\\n";
    } else {
      if (c == "\t") {
        out = out + "\\t";
      } else {
        if (c == "\\") {
          out = out + "\\\\";
        } else {
          if (c == "\"") {
            out = out + "\\\"";
          } else {
            out = out + c;
          }
        }
      }
    }
    j = j + 1;
  }
  return out;
}

let src = "";
let i = 0;

fun at_end() { return i >= len(src); }
fun peek() { return char_at(src, i); }
fun peek_next() { return char_at(src, i + 1); }

fun advance_char() {
  let c = char_at(src, i);
  i = i + 1;
  return c;
}

fun match_char(expected) {
  if (at_end()) return false;
  if (char_at(src, i) != expected) return false;
  i = i + 1;
  return true;
}

fun skip_ws_and_comments() {
  while (!at_end()) {
    let c = peek();
    if (c == " " or c == "\t" or c == "\n") {
      i = i + 1;
    } else {
      if (c == "/" and peek_next() == "/") {
        while (!at_end() and peek() != "\n") {
          i = i + 1;
        }
      } else {
        return;
      }
    }
  }
}

fun lex_string() {
  let value = "";
  while (!at_end() and peek() != "\"") {
    let c = advance_char();
    if (c == "\\") {
      if (at_end()) return make_token("Invalid", "Unterminated string");
      let e = advance_char();
      if (e == "n") {
        value = value + "\n";
      } else {
        if (e == "t") {
          value = value + "\t";
        } else {
          if (e == "\"") {
            value = value + "\"";
          } else {
            if (e == "\\") {
              value = value + "\\";
            } else {
              value = value + e;
            }
          }
        }
      }
    } else {
      value = value + c;
    }
  }
  if (at_end()) return make_token("Invalid", "Unterminated string");
  i = i + 1;
  return make_token("String", value);
}

fun lex_number(first) {
  let lex = first;
  while (is_digit(peek())) { lex = lex + advance_char(); }
  if (peek() == "." and is_digit(peek_next())) {
    lex = lex + advance_char();
    while (is_digit(peek())) { lex = lex + advance_char(); }
  }
  return make_token("Number", lex);
}

fun keyword_type(lex) {
  if (lex == "let") return "Let";
  if (lex == "print") return "Print";
  if (lex == "if") return "If";
  if (lex == "else") return "Else";
  if (lex == "while") return "While";
  if (lex == "fun") return "Fun";
  if (lex == "return") return "Return";
  if (lex == "true") return "True";
  if (lex == "false") return "False";
  if (lex == "nil") return "Nil";
  if (lex == "and") return "And";
  if (lex == "or") return "Or";
  return "Identifier";
}

fun lex_identifier(first) {
  let lex = first;
  while (is_alnum(peek())) { lex = lex + advance_char(); }
  return make_token(keyword_type(lex), lex);
}

fun lex_token() {
  skip_ws_and_comments();
  if (at_end()) return make_token("Eof", "");

  let c = advance_char();

  if (c == "(") return make_token("LeftParen", "(");
  if (c == ")") return make_token("RightParen", ")");
  if (c == "{") return make_token("LeftBrace", "{");
  if (c == "}") return make_token("RightBrace", "}");
  if (c == ";") return make_token("Semicolon", ";");
  if (c == ",") return make_token("Comma", ",");
  if (c == "+") return make_token("Plus", "+");
  if (c == "-") return make_token("Minus", "-");
  if (c == "*") return make_token("Star", "*");
  if (c == "/") return make_token("Slash", "/");

  if (c == "!") {
    if (match_char("=")) return make_token("BangEqual", "!=");
    return make_token("Bang", "!");
  }
  if (c == "=") {
    if (match_char("=")) return make_token("EqualEqual", "==");
    return make_token("Equal", "=");
  }
  if (c == "<") {
    if (match_char("=")) return make_token("LessEqual", "<=");
    return make_token("Less", "<");
  }
  if (c == ">") {
    if (match_char("=")) return make_token("GreaterEqual", ">=");
    return make_token("Greater", ">");
  }
  if (c == "\"") return lex_string();

  if (is_digit(c)) return lex_number(c);
  if (is_alpha(c)) return lex_identifier(c);

  return make_token("Invalid", c);
}

fun lex_all() {
  let tokens = list();
  while (true) {
    let t = lex_token();
    tokens = push(tokens, t);
    if (tok_type(t) == "Eof") return tokens;
  }
}

let tokens = list();
let current = 0;

fun has_next() { return current + 1 < len(tokens); }
fun peek_tok() { return get(tokens, current); }
fun previous_tok() { return get(tokens, current - 1); }
fun peek_next_tok() { return get(tokens, current + 1); }

fun check(t) { return tok_type(peek_tok()) == t; }
fun check_next(t) {
  if (!has_next()) return false;
  return tok_type(peek_next_tok()) == t;
}

fun is_at_end_tok() { return check("Eof"); }

fun advance_tok() {
  if (!is_at_end_tok()) current = current + 1;
  return previous_tok();
}

fun match_tok(t) {
  if (check(t)) {
    advance_tok();
    return true;
  }
  return false;
}

fun consume(t, msg) {
  if (check(t)) return advance_tok();
  let got = peek_tok();
  print "Parse error: " + msg + " (got " + tok_type(got) + " '" + tok_lex(got) + "')";
  return make_token("Invalid", msg);
}

fun parse_program() {
  let out = "(program";
  while (!check("Eof")) {
    out = out + " " + parse_declaration();
  }
  out = out + ")";
  return out;
}

fun parse_declaration() {
  if (match_tok("Fun")) return parse_fun_decl();
  if (match_tok("Let")) return parse_let_stmt();
  return parse_stmt();
}

fun parse_fun_decl() {
  let nameTok = consume("Identifier", "Expected function name");
  let name = tok_lex(nameTok);
  consume("LeftParen", "Expected '(' after function name");
  let params = list();
  if (!check("RightParen")) {
    let done = false;
    while (!done) {
      let p = consume("Identifier", "Expected parameter name");
      params = push(params, tok_lex(p));
      if (!match_tok("Comma")) done = true;
    }
  }
  consume("RightParen", "Expected ')' after parameters");
  consume("LeftBrace", "Expected '{' before function body");
  let body = "(block";
  while (!check("RightBrace") and !check("Eof")) {
    body = body + " " + parse_declaration();
  }
  consume("RightBrace", "Expected '}' after function body");
  let out = "(fun " + name + " (params";
  let j = 0;
  while (j < len(params)) {
    out = out + " " + get(params, j);
    j = j + 1;
  }
  out = out + ") " + body + "))";
  return out;
}

fun parse_let_stmt() {
  let nameTok = consume("Identifier", "Expected identifier after let");
  consume("Equal", "Expected '=' after variable name");
  let init = parse_expr();
  consume("Semicolon", "Expected ';' after let");
  return "(let " + tok_lex(nameTok) + " " + init + ")";
}

fun parse_print_stmt() {
  let e = parse_expr();
  consume("Semicolon", "Expected ';' after print");
  return "(print " + e + ")";
}

fun parse_block_stmt() {
  let out = "(block";
  while (!check("RightBrace") and !check("Eof")) {
    out = out + " " + parse_declaration();
  }
  consume("RightBrace", "Expected '}' after block");
  out = out + ")";
  return out;
}

fun parse_if_stmt() {
  consume("LeftParen", "Expected '(' after if");
  let cond = parse_expr();
  consume("RightParen", "Expected ')' after if condition");
  let thenS = parse_stmt();
  if (match_tok("Else")) {
    let elseS = parse_stmt();
    return "(if " + cond + " " + thenS + " " + elseS + ")";
  }
  return "(if " + cond + " " + thenS + ")";
}

fun parse_while_stmt() {
  consume("LeftParen", "Expected '(' after while");
  let cond = parse_expr();
  consume("RightParen", "Expected ')' after while condition");
  let body = parse_stmt();
  return "(while " + cond + " " + body + ")";
}

fun parse_return_stmt() {
  if (check("Semicolon")) {
    advance_tok();
    return "(return)";
  }
  let v = parse_expr();
  consume("Semicolon", "Expected ';' after return");
  return "(return " + v + ")";
}

fun parse_assign_stmt() {
  let nameTok = consume("Identifier", "Expected identifier");
  consume("Equal", "Expected '=' in assignment");
  let v = parse_expr();
  consume("Semicolon", "Expected ';' after assignment");
  return "(assign " + tok_lex(nameTok) + " " + v + ")";
}

fun parse_expr_stmt() {
  let e = parse_expr();
  consume("Semicolon", "Expected ';' after expression");
  return "(expr " + e + ")";
}

fun parse_stmt() {
  if (match_tok("Print")) return parse_print_stmt();
  if (match_tok("If")) return parse_if_stmt();
  if (match_tok("While")) return parse_while_stmt();
  if (match_tok("Return")) return parse_return_stmt();
  if (match_tok("LeftBrace")) return parse_block_stmt();
  if (check("Identifier") and check_next("Equal")) return parse_assign_stmt();
  return parse_expr_stmt();
}

fun parse_expr() { return parse_or(); }

fun parse_or() {
  let e = parse_and();
  while (match_tok("Or")) {
    let op = tok_lex(previous_tok());
    let r = parse_and();
    e = "(" + op + " " + e + " " + r + ")";
  }
  return e;
}

fun parse_and() {
  let e = parse_equality();
  while (match_tok("And")) {
    let op = tok_lex(previous_tok());
    let r = parse_equality();
    e = "(" + op + " " + e + " " + r + ")";
  }
  return e;
}

fun parse_equality() {
  let e = parse_comparison();
  while (match_tok("EqualEqual") or match_tok("BangEqual")) {
    let op = tok_lex(previous_tok());
    let r = parse_comparison();
    e = "(" + op + " " + e + " " + r + ")";
  }
  return e;
}

fun parse_comparison() {
  let e = parse_term();
  while (match_tok("Greater") or match_tok("GreaterEqual") or match_tok("Less") or match_tok("LessEqual")) {
    let op = tok_lex(previous_tok());
    let r = parse_term();
    e = "(" + op + " " + e + " " + r + ")";
  }
  return e;
}

fun parse_term() {
  let e = parse_factor();
  while (match_tok("Plus") or match_tok("Minus")) {
    let op = tok_lex(previous_tok());
    let r = parse_factor();
    e = "(" + op + " " + e + " " + r + ")";
  }
  return e;
}

fun parse_factor() {
  let e = parse_unary();
  while (match_tok("Star") or match_tok("Slash")) {
    let op = tok_lex(previous_tok());
    let r = parse_unary();
    e = "(" + op + " " + e + " " + r + ")";
  }
  return e;
}

fun parse_unary() {
  if (match_tok("Bang") or match_tok("Minus")) {
    let op = tok_lex(previous_tok());
    let r = parse_unary();
    return "(" + op + " " + r + ")";
  }
  return parse_call();
}

fun parse_call() {
  let e = parse_primary();
  while (match_tok("LeftParen")) {
    let out = "(call " + e;
    if (!check("RightParen")) {
      let done = false;
      while (!done) {
        out = out + " " + parse_expr();
        if (!match_tok("Comma")) done = true;
      }
    }
    consume("RightParen", "Expected ')' after arguments");
    out = out + ")";
    e = out;
  }
  return e;
}

fun parse_primary() {
  if (match_tok("Number")) return tok_lex(previous_tok());
  if (match_tok("String")) return "\"" + escape_string(tok_lex(previous_tok())) + "\"";
  if (match_tok("True")) return "true";
  if (match_tok("False")) return "false";
  if (match_tok("Nil")) return "nil";
  if (match_tok("Identifier")) return tok_lex(previous_tok());
  if (match_tok("LeftParen")) {
    let e = parse_expr();
    consume("RightParen", "Expected ')'");
    return "(group " + e + ")";
  }
  print "Parse error: Expected expression";
  return "nil";
}

src = input;
i = 0;
tokens = lex_all();
current = 0;
print parse_program();
